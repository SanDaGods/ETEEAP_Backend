require("dotenv").config();
const express = require("express");
const mongoose = require("mongoose");
const bodyParser = require('body-parser');
const path = require("path");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const cookieParser = require("cookie-parser");
const cors = require("cors");
const multer = require('multer');
const fs = require("fs");

const app = express();
const PORT = 3000;
const JWT_SECRET = process.env.JWT_SECRET || "your_jwt_secret_here";

// Middleware
app.use(express.json());
app.use(cookieParser());
app.use(cors({ 
  origin: true,
  credentials: true,
  exposedHeaders: ['set-cookie']
}));
app.use(bodyParser.json());

// Serve static files
app.use(express.static(path.join(__dirname, "public")));

// MongoDB Connection
mongoose.connect("mongodb://127.0.0.1:27017/Eteeap", {
  useNewUrlParser: true,
  useUnifiedTopology: true,
});

const db = mongoose.connection;
db.on("error", console.error.bind(console, "MongoDB connection error:"));
db.once("open", () => console.log("‚úÖ MongoDB connected successfully"));

// Default route
app.get("/", (req, res) => {
  res.sendFile(path.join(__dirname, "public", "frontend", "Applicant", "Home", "index.html"));
});

// ======================
// USER ROUTES (Applicant System)
// ======================
const applicantSchema = new mongoose.Schema({
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true },
  status: { type: String, default: "Pending Review" },
  personalInfo: {
    firstname: String,
    middlename: String,
    lastname: String,
    suffix: String,
    gender: String,
    age: Number,
    occupation: String,
    nationality: String,
    civilstatus: String,
    birthDate: Date,
    birthplace: String,
    mobileNumber: String,
    telephoneNumber: String,
    emailAddress: String,
    country: String,
    province: String,
    city: String,
    street: String,
    zipCode: String,
    firstPriorityCourse: String,
    secondPriorityCourse: String,
    thirdPriorityCourse: String,
  },
  files: [String],
  createdAt: { type: Date, default: Date.now }
}, { collection: "Applicants" });

const Applicant = mongoose.model("Applicant", applicantSchema);

// Set up multer for file uploads
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, path.join(__dirname, 'backend', 'uploads'));
  },
  filename: (req, file, cb) => {
    cb(null, Date.now() + path.extname(file.originalname));
  }
});

const upload = multer({ storage: storage });

// Applicant Auth Middleware
const applicantAuthMiddleware = async (req, res, next) => {
  const token = req.cookies.applicantToken;
  
  if (!token) {
    return res.status(401).json({ error: "Not authenticated" });
  }

  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    req.applicant = decoded;
    next();
  } catch (err) {
    res.status(401).json({ error: "Invalid token" });
  }
};

// Applicant Register
app.post("/api/register", async (req, res) => {
  const { email, password } = req.body;

  try {
    const existingUser = await Applicant.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ success: false, error: "Email already registered" });
    }

    const hashedPassword = await bcrypt.hash(password, 10);
    const newApplicant = new Applicant({ email, password: hashedPassword });

    await newApplicant.save();
    res.json({ 
      success: true, 
      message: "Registration successful!",
      userId: newApplicant._id 
    });
  } catch (error) {
    console.error("Registration error:", error);
    res.status(500).json({ success: false, error: "Server error" });
  }
});

// Applicant Login
app.post("/api/login", async (req, res) => {
  const { email, password } = req.body;

  try {
    const applicant = await Applicant.findOne({ email });
    if (!applicant) {
      return res.status(401).json({ 
        success: false, 
        error: "Invalid credentials" 
      });
    }

    const isMatch = await bcrypt.compare(password, applicant.password);
    if (!isMatch) {
      return res.status(401).json({ 
        success: false, 
        error: "Invalid credentials" 
      });
    }

    const token = jwt.sign(
      { 
        userId: applicant._id, 
        role: "applicant",
        email: applicant.email
      }, 
      JWT_SECRET, 
      { expiresIn: "1h" }
    );

    res.cookie("applicantToken", token, { 
      httpOnly: true, 
      secure: process.env.NODE_ENV === "production",
      maxAge: 3600000,
      sameSite: process.env.NODE_ENV === "production" ? "strict" : "lax",
      path: "/"
    });

    res.json({ 
      success: true, 
      message: "Login successful",
      data: {
        userId: applicant._id,
        email: applicant.email
      }
    });
  } catch (error) {
    console.error("Login error:", error);
    res.status(500).json({ 
      success: false, 
      error: "Login failed" 
    });
  }
});

// Update personal info route
app.post("/api/update-personal-info", upload.array('files'), async (req, res) => {
  const { userId, personalInfo } = req.body;

  try {
    if (!mongoose.Types.ObjectId.isValid(userId)) {
      return res.status(400).json({ success: false, error: 'Invalid userId' });
    }

    const applicant = await Applicant.findById(userId);
    if (!applicant) {
      return res.status(404).json({ success: false, error: 'User not found' });
    }

    applicant.personalInfo = JSON.parse(personalInfo);

    if (req.files) {
      applicant.files = req.files.map(file => path.join('uploads', path.basename(file.path)));
    }

    await applicant.save();

    res.status(200).json({ 
      success: true,
      message: 'Personal information updated successfully' 
    });
  } catch (error) {
    console.error("Error updating personal info:", error);
    res.status(500).json({ 
      success: false,
      error: 'Error updating personal info' 
    });
  }
});

// Get applicant profile
app.get("/api/profile/:userId", async (req, res) => {
  try {
    const userId = req.params.userId;

    if (!mongoose.Types.ObjectId.isValid(userId)) {
      return res.status(400).json({ 
        success: false, 
        error: 'Invalid user ID' 
      });
    }

    const applicant = await Applicant.findById(userId).select('-password');
    if (!applicant) {
      return res.status(404).json({ 
        success: false, 
        error: 'User not found' 
      });
    }

    res.status(200).json({ 
      success: true,
      data: applicant 
    });
  } catch (error) {
    console.error('Error fetching user profile:', error);
    res.status(500).json({ 
      success: false,
      error: 'Server error' 
    });
  }
});

// Applicant Auth Status
app.get("/applicant/auth-status", async (req, res) => {
  try {
    const token = req.cookies.applicantToken;
    
    if (!token) {
      return res.status(200).json({ 
        authenticated: false,
        message: "No token found"
      });
    }

    const decoded = jwt.verify(token, JWT_SECRET);
    const applicant = await Applicant.findOne({ _id: decoded.userId }).select('-password');
    
    if (!applicant) {
      return res.status(200).json({ 
        authenticated: false,
        message: "Applicant not found"
      });
    }

    res.status(200).json({ 
      authenticated: true,
      user: {
        _id: applicant._id,
        email: applicant.email,
        personalInfo: applicant.personalInfo,
        files: applicant.files
      }
    });
  } catch (err) {
    console.error("Applicant auth status error:", err);
    res.status(200).json({ 
      authenticated: false,
      message: "Invalid token"
    });
  }
});

// Applicant Logout
app.post("/applicant/logout", (req, res) => {
  res.clearCookie("applicantToken");
  res.json({ success: true, message: "Logged out successfully" });
});

// ======================
// ASSESSOR SYSTEM
// ======================
const assessorCounterSchema = new mongoose.Schema({
  _id: { type: String, required: true },
  seq: { type: Number, default: 1000 }
}, { collection: "AssessorCounters" });

const AssessorCounter = mongoose.model("AssessorCounter", assessorCounterSchema);

const assessorSchema = new mongoose.Schema({
  email: { 
    type: String, 
    unique: true, 
    required: true,
    match: [/^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/, 'Invalid email']
  },
  password: { 
    type: String, 
    required: true,
    minlength: 8,
  },
  assessorId: { 
    type: String, 
    unique: true,
    uppercase: true
  },
  fullName: {
    type: String,
    required: true
  },
  expertise: {
    type: String,
    required: true,
    enum: ["engineering", "education", "business", "information_technology", 
           "health_sciences", "arts_sciences", "architecture", 
           "industrial_technology", "hospitality_management", "other"]
  },
  assessorType: {
    type: String,
    required: true,
    enum: ["external", "internal"]
  },
  isApproved: { 
    type: Boolean, 
    default: false 
  },
  createdAt: { 
    type: Date, 
    default: Date.now 
  },
  lastLogin: Date
}, { collection: "Assessors" });

const Assessor = mongoose.model("Assessor", assessorSchema);

// Auth Middleware for Assessors
const assessorAuthMiddleware = async (req, res, next) => {
  const token = req.cookies.assessorToken;
  
  if (!token) {
    return res.status(401).json({ error: "Not authenticated" });
  }

  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    req.assessor = decoded;
    next();
  } catch (err) {
    res.status(401).json({ error: "Invalid token" });
  }
};

// Generate Assessor ID
async function getNextAssessorId() {
  const counter = await AssessorCounter.findByIdAndUpdate(
    'assessorId',
    { $inc: { seq: 1 } },
    { new: true, upsert: true }
  );
  return `AST${counter.seq.toString().padStart(4, '0')}`;
}

// Assessor Registration
app.post("/assessor/register", async (req, res) => {
  const { email, password, fullName, expertise, assessorType } = req.body;

  try {
    if (!email || !password || !fullName || !expertise || !assessorType) {
      return res.status(400).json({ 
        success: false, 
        error: "All fields are required" 
      });
    }

    if (password.length < 8 || password.length > 16) {
      return res.status(400).json({
        success: false,
        error: "Password must be 8-16 characters"
      });
    }

    const assessorId = await getNextAssessorId();
    const existing = await Assessor.findOne({ email: email.toLowerCase() });
    
    if (existing) {
      return res.status(400).json({ 
        success: false, 
        error: "Email already registered" 
      });
    }

    const hashedPassword = await bcrypt.hash(password, 10);
    const newAssessor = new Assessor({ 
      email: email.toLowerCase(),
      password: hashedPassword,
      assessorId,
      fullName,
      expertise,
      assessorType
    });

    await newAssessor.save();

    res.status(201).json({ 
      success: true, 
      message: "Registration successful",
      data: {
        email: newAssessor.email,
        assessorId: newAssessor.assessorId,
        fullName: newAssessor.fullName,
        expertise: newAssessor.expertise,
        assessorType: newAssessor.assessorType
      }
    });

  } catch (error) {
    console.error("Registration error:", error);
    res.status(500).json({ 
      success: false, 
      error: "Registration failed - Server error"
    });
  }
});

// Assessor Login
app.post("/assessor/login", async (req, res) => {
  const { email, password } = req.body;

  try {
    const assessor = await Assessor.findOne({ 
      email: { $regex: new RegExp(`^${email}$`, 'i') }
    });

    if (!assessor) {
      return res.status(401).json({ 
        success: false, 
        error: "Invalid credentials" 
      });
    }

    if (!assessor.isApproved) {
      return res.status(403).json({ 
        success: false, 
        error: "Account pending admin approval" 
      });
    }

    const isMatch = await bcrypt.compare(password, assessor.password);
    if (!isMatch) {
      return res.status(401).json({ 
        success: false, 
        error: "Invalid credentials" 
      });
    }

    assessor.lastLogin = new Date();
    await assessor.save();

    const token = jwt.sign(
      { 
        userId: assessor._id, 
        role: "assessor",
        assessorId: assessor.assessorId,
        email: assessor.email,
        fullName: assessor.fullName,
        expertise: assessor.expertise,
        assessorType: assessor.assessorType
      }, 
      JWT_SECRET, 
      { expiresIn: "1h" }
    );

    res.cookie("assessorToken", token, { 
      httpOnly: true, 
      secure: process.env.NODE_ENV === "production",
      maxAge: 3600000,
      sameSite: process.env.NODE_ENV === "production" ? "strict" : "lax",
      path: "/"
    });

    res.json({ 
      success: true, 
      message: "Login successful",
      data: {
        assessorId: assessor.assessorId,
        email: assessor.email,
        fullName: assessor.fullName,
        expertise: assessor.expertise,
        assessorType: assessor.assessorType
      }
    });
  } catch (error) {
    console.error("Login error:", error);
    res.status(500).json({ 
      success: false, 
      error: "Login failed" 
    });
  }
});

// Serve Assessor Dashboard
app.get("/assessor-dashboard", assessorAuthMiddleware, (req, res) => {
  res.sendFile(
    path.join(__dirname, "public", "frontend", "AssessorSide", "AssessorDashboard", "AssessorDashboard.html")
  );
});

// Assessor Auth Status
app.get("/assessor/auth-status", async (req, res) => {
  try {
    const token = req.cookies.assessorToken;
    
    if (!token) {
      return res.status(200).json({ 
        authenticated: false,
        message: "No token found"
      });
    }

    const decoded = jwt.verify(token, JWT_SECRET);
    const assessor = await Assessor.findOne({ _id: decoded.userId }).select('-password');
    
    if (!assessor) {
      return res.status(200).json({ 
        authenticated: false,
        message: "Assessor not found"
      });
    }

    res.status(200).json({ 
      authenticated: true,
      user: {
        _id: assessor._id,
        assessorId: assessor.assessorId,
        email: assessor.email,
        fullName: assessor.fullName,
        expertise: assessor.expertise,
        assessorType: assessor.assessorType,
        isApproved: assessor.isApproved,
        createdAt: assessor.createdAt,
        lastLogin: assessor.lastLogin
      }
    });
  } catch (err) {
    console.error("Auth status error:", err);
    res.status(200).json({ 
      authenticated: false,
      message: "Invalid token"
    });
  }
});

// Assessor Logout
app.post("/assessor/logout", (req, res) => {
  res.clearCookie("assessorToken");
  res.json({ success: true, message: "Logged out successfully" });
});

// ======================
// ADMIN SYSTEM
// ======================
const adminSchema = new mongoose.Schema({
  email: { 
    type: String, 
    unique: true, 
    required: true,
    match: [/^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/, 'Invalid email']
  },
  password: { 
    type: String, 
    required: true,
    minlength: 8,
  },
  fullName: {
    type: String,
    required: true
  },
  isSuperAdmin: {
    type: Boolean,
    default: false
  },
  lastLogin: Date,
  createdAt: { 
    type: Date, 
    default: Date.now 
  }
}, { collection: "Admins" });

const Admin = mongoose.model("Admin", adminSchema);

// Admin Auth Middleware
const adminAuthMiddleware = async (req, res, next) => {
  const token = req.cookies.adminToken;
  
  if (!token) {
    return res.status(401).json({ error: "Not authenticated" });
  }

  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    req.admin = decoded;
    next();
  } catch (err) {
    res.status(401).json({ error: "Invalid token" });
  }
};

// Admin Registration Endpoint
app.post("/admin/register", async (req, res) => {
  try {
    const { email, password, fullName } = req.body;

    if (!email || !password || !fullName) {
      return res.status(400).json({ 
        success: false, 
        error: "All fields are required" 
      });
    }

    if (password.length < 8 || password.length > 16) {
      return res.status(400).json({
        success: false,
        error: "Password must be 8-16 characters"
      });
    }

    const adminCount = await Admin.countDocuments();
    let isSuperAdmin = false;

    if (adminCount > 0) {
      const token = req.cookies.adminToken;
      
      if (!token) {
        return res.status(401).json({ 
          success: false, 
          error: "Authentication required - please login first" 
        });
      }

      try {
        const decoded = jwt.verify(token, JWT_SECRET);
        const requestingAdmin = await Admin.findById(decoded.userId);
        
        if (!requestingAdmin || !requestingAdmin.isSuperAdmin) {
          return res.status(403).json({ 
            success: false, 
            error: "Only super admins can register new admins" 
          });
        }
      } catch (err) {
        return res.status(401).json({ 
          success: false, 
          error: "Invalid authentication token" 
        });
      }
    } else {
      isSuperAdmin = true;
    }

    const existing = await Admin.findOne({ email: email.toLowerCase() });
    
    if (existing) {
      return res.status(400).json({ 
        success: false, 
        error: "Email already registered" 
      });
    }

    const hashedPassword = await bcrypt.hash(password, 10);
    const newAdmin = new Admin({ 
      email: email.toLowerCase(),
      password: hashedPassword,
      fullName,
      isSuperAdmin
    });

    await newAdmin.save();

    return res.status(201).json({ 
      success: true, 
      message: "Admin registration successful. Please login.",
      redirectTo: "/frontend/AdminSide/1.adminLogin/adminlogin.html",
      data: {
        email: newAdmin.email,
        fullName: newAdmin.fullName,
        isSuperAdmin: newAdmin.isSuperAdmin,
        createdAt: newAdmin.createdAt
      }
    });

  } catch (error) {
    console.error("Admin registration error:", error);
    return res.status(500).json({ 
      success: false, 
      error: "Admin registration failed - Server error"
    });
  }
});

// Admin Login
app.post("/admin/login", async (req, res) => {
  const { email, password } = req.body;

  try {
    const admin = await Admin.findOne({ 
      email: { $regex: new RegExp(`^${email}$`, 'i') }
    });

    if (!admin) {
      return res.status(401).json({ 
        success: false, 
        error: "Invalid credentials" 
      });
    }

    const isMatch = await bcrypt.compare(password, admin.password);
    if (!isMatch) {
      return res.status(401).json({ 
        success: false, 
        error: "Invalid credentials" 
      });
    }

    admin.lastLogin = new Date();
    await admin.save();

    const token = jwt.sign(
      { 
        userId: admin._id, 
        role: "admin",
        email: admin.email,
        fullName: admin.fullName,
        isSuperAdmin: admin.isSuperAdmin
      }, 
      JWT_SECRET, 
      { expiresIn: "8h" }
    );

    res.cookie("adminToken", token, { 
      httpOnly: true, 
      secure: process.env.NODE_ENV === "production",
      maxAge: 28800000,
      sameSite: process.env.NODE_ENV === "production" ? "strict" : "lax",
      path: "/"
    });

    res.json({ 
      success: true, 
      message: "Login successful",
      redirectTo: "/frontend/AdminSide/2.adminDash/admin.html",
      data: {
        email: admin.email,
        fullName: admin.fullName,
        isSuperAdmin: admin.isSuperAdmin
      }
    });
  } catch (error) {
    console.error("Admin login error:", error);
    res.status(500).json({ 
      success: false, 
      error: "Login failed" 
    });
  }
});

// Admin Auth Status
app.get("/admin/auth-status", async (req, res) => {
  try {
    const token = req.cookies.adminToken;
    
    if (!token) {
      return res.status(200).json({ 
        authenticated: false,
        message: "No token found"
      });
    }

    const decoded = jwt.verify(token, JWT_SECRET);
    const admin = await Admin.findOne({ _id: decoded.userId }).select('-password');
    
    if (!admin) {
      return res.status(200).json({ 
        authenticated: false,
        message: "Admin not found"
      });
    }

    res.status(200).json({ 
      authenticated: true,
      user: {
        _id: admin._id,
        email: admin.email,
        fullName: admin.fullName,
        isSuperAdmin: admin.isSuperAdmin,
        createdAt: admin.createdAt,
        lastLogin: admin.lastLogin
      }
    });
  } catch (err) {
    console.error("Admin auth status error:", err);
    res.status(200).json({ 
      authenticated: false,
      message: "Invalid token"
    });
  }
});

// Admin Logout
app.post("/admin/logout", (req, res) => {
  res.clearCookie("adminToken");
  res.json({ success: true, message: "Admin logged out successfully" });
});

// Admin Dashboard Route
app.get("/frontend/AdminSide/2.adminDash/admin.html", adminAuthMiddleware, (req, res) => {
  res.sendFile(
    path.join(__dirname, "public", "frontend", "AdminSide", "2.adminDash", "admin.html")
  );
});

// Get all applicants for admin
app.get("/api/admin/applicants", adminAuthMiddleware, async (req, res) => {
  try {
    const applicants = await Applicant.find({})
      .select('-password -files -__v')
      .sort({ createdAt: -1 });

    const formattedApplicants = applicants.map(applicant => {
      return {
        _id: applicant._id,
        applicantId: `APP${applicant._id.toString().substring(0, 8).toUpperCase()}`,
        name: applicant.personalInfo ? 
          `${applicant.personalInfo.lastname || ''}, ${applicant.personalInfo.firstname || ''} ${applicant.personalInfo.middlename || ''}`.trim() : 
          'No name provided',
        course: applicant.personalInfo?.firstPriorityCourse || 'Not specified',
        applicationDate: applicant.createdAt || new Date(),
        currentScore: 0,
        status: applicant.status || 'Pending Review'
      };
    });

    res.status(200).json({ 
      success: true,
      data: formattedApplicants 
    });
  } catch (error) {
    console.error('Error fetching applicants:', error);
    res.status(500).json({ 
      success: false,
      error: 'Failed to fetch applicants' 
    });
  }
});

// Get single applicant by ID for admin
app.get("/api/admin/applicants/:id", adminAuthMiddleware, async (req, res) => {
  try {
    const applicantId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(applicantId)) {
      return res.status(400).json({ 
        success: false, 
        error: 'Invalid applicant ID' 
      });
    }

    const applicant = await Applicant.findById(applicantId)
      .select('-password -__v');

    if (!applicant) {
      return res.status(404).json({ 
        success: false, 
        error: 'Applicant not found' 
      });
    }

    const formattedApplicant = {
      _id: applicant._id,
      applicantId: `APP${applicant._id.toString().substring(0, 8).toUpperCase()}`,
      email: applicant.email,
      status: applicant.status,
      createdAt: applicant.createdAt,
      personalInfo: applicant.personalInfo,
      files: applicant.files,
      name: applicant.personalInfo ? 
        `${applicant.personalInfo.lastname || ''}, ${applicant.personalInfo.firstname || ''} ${applicant.personalInfo.middlename || ''}`.trim() : 
        'No name provided',
      course: applicant.personalInfo?.firstPriorityCourse || 'Not specified'
    };

    res.status(200).json({ 
      success: true,
      data: formattedApplicant 
    });
  } catch (error) {
    console.error('Error fetching applicant:', error);
    res.status(500).json({ 
      success: false,
      error: 'Failed to fetch applicant' 
    });
  }
});

// Approve applicant
app.post("/api/admin/applicants/:id/approve", adminAuthMiddleware, async (req, res) => {
  try {
    const applicantId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(applicantId)) {
      return res.status(400).json({ 
        success: false, 
        error: 'Invalid applicant ID' 
      });
    }

    const updatedApplicant = await Applicant.findByIdAndUpdate(
      applicantId,
      { status: "Approved" },
      { new: true }
    ).select('-password -files -__v');

    if (!updatedApplicant) {
      return res.status(404).json({ 
        success: false, 
        error: 'Applicant not found' 
      });
    }

    res.status(200).json({ 
      success: true,
      message: 'Applicant approved successfully',
      data: updatedApplicant
    });
  } catch (error) {
    console.error('Error approving applicant:', error);
    res.status(500).json({ 
      success: false,
      error: 'Failed to approve applicant' 
    });
  }
});

// Reject applicant
app.post("/api/admin/applicants/:id/reject", adminAuthMiddleware, async (req, res) => {
  try {
    const applicantId = req.params.id;
    
    if (!mongoose.Types.ObjectId.isValid(applicantId)) {
      return res.status(400).json({ 
        success: false, 
        error: 'Invalid applicant ID' 
      });
    }

    const updatedApplicant = await Applicant.findByIdAndUpdate(
      applicantId,
      { status: "Rejected" },
      { new: true }
    ).select('-password -files -__v');

    if (!updatedApplicant) {
      return res.status(404).json({ 
        success: false, 
        error: 'Applicant not found' 
      });
    }

    res.status(200).json({ 
      success: true,
      message: 'Applicant rejected successfully',
      data: updatedApplicant
    });
  } catch (error) {
    console.error('Error rejecting applicant:', error);
    res.status(500).json({ 
      success: false,
      error: 'Failed to reject applicant' 
    });
  }
});

// Admin dashboard stats
app.get("/api/admin/dashboard-stats", adminAuthMiddleware, async (req, res) => {
  try {
    const totalApplicants = await Applicant.countDocuments();
    const newApplicants = await Applicant.countDocuments({ 
      createdAt: { $gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) }
    });
    const pendingReview = await Applicant.countDocuments({ status: "Pending Review" });
    const rejected = await Applicant.countDocuments({ status: "Rejected" });

    res.status(200).json({
      success: true,
      data: {
        totalApplicants,
        newApplicants,
        pendingReview,
        rejected
      }
    });
  } catch (error) {
    console.error('Error fetching dashboard stats:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch dashboard stats'
    });
  }
});

// Get all assessors
app.get("/assessor/all", adminAuthMiddleware, async (req, res) => {
  try {
    const assessors = await Assessor.find({})
      .select('-password -__v')
      .sort({ createdAt: -1 });

    // Add applicants count to each assessor
    const assessorsWithCounts = await Promise.all(assessors.map(async assessor => {
      const count = await Applicant.countDocuments({
        status: "Under Assessment",
        "assignedAssessors": assessor._id
      });
      return {
        ...assessor.toObject(),
        applicantsCount: count
      };
    }));

    res.status(200).json({
      success: true,
      data: assessorsWithCounts
    });
  } catch (error) {
    console.error('Error fetching assessors:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch assessors'
    });
  }
});

// Get single assessor
app.get("/assessor/:id", adminAuthMiddleware, async (req, res) => {
  try {
    const assessor = await Assessor.findById(req.params.id)
      .select('-password -__v');

    if (!assessor) {
      return res.status(404).json({
        success: false,
        error: 'Assessor not found'
      });
    }

    res.status(200).json({
      success: true,
      data: assessor
    });
  } catch (error) {
    console.error('Error fetching assessor:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch assessor'
    });
  }
});

// Update assessor
app.put("/assessor/:id", adminAuthMiddleware, async (req, res) => {
  try {
    const { fullName, email, assessorType, expertise } = req.body;
    
    const updatedAssessor = await Assessor.findByIdAndUpdate(
      req.params.id,
      { fullName, email, assessorType, expertise },
      { new: true, runValidators: true }
    ).select('-password -__v');

    if (!updatedAssessor) {
      return res.status(404).json({
        success: false,
        error: 'Assessor not found'
      });
    }

    res.status(200).json({
      success: true,
      message: 'Assessor updated successfully',
      data: updatedAssessor
    });
  } catch (error) {
    console.error('Error updating assessor:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to update assessor'
    });
  }
});

// Delete assessor
app.delete("/assessor/:id", adminAuthMiddleware, async (req, res) => {
  try {
    const deletedAssessor = await Assessor.findByIdAndDelete(req.params.id);

    if (!deletedAssessor) {
      return res.status(404).json({
        success: false,
        error: 'Assessor not found'
      });
    }

    res.status(200).json({
      success: true,
      message: 'Assessor deleted successfully'
    });
  } catch (error) {
    console.error('Error deleting assessor:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to delete assessor'
    });
  }
});

// Serve documents
app.get('/documents/:filename', (req, res) => {
  const filename = req.params.filename;
  
  if (!filename.endsWith('.pdf') || !/^[a-zA-Z0-9_\-\.]+\.pdf$/.test(filename)) {
      return res.status(400).json({ error: 'Only PDF files are supported' });
  }

  const filePath = path.join(__dirname, 'public', 'documents', filename);
  
  if (!fs.existsSync(filePath)) {
      return res.status(404).json({ error: 'File not found' });
  }

  res.setHeader('Content-Type', 'application/pdf');
  res.sendFile(filePath);
});

// Create uploads directory if it doesn't exist
const uploadsDir = path.join(__dirname, 'public', 'uploads');
if (!fs.existsSync(uploadsDir)) {
  fs.mkdirSync(uploadsDir, { recursive: true });
}

// Start Server
app.listen(PORT, () => {
  console.log(`üöÄ Server running at http://localhost:${PORT}`);
  console.log(`üìÅ MongoDB collections:`);
  console.log(`- Eteeap.Applicants`);
  console.log(`- Eteeap.Assessors`);
  console.log(`- Eteeap.AssessorCounters`);
  console.log(`- Eteeap.Admins`);
});